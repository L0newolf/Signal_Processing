
/*!
 * (23,12,7) Covolutional FEC implementation by Mandar Chitre.
 * Taken from doppler resiliant scheme implementation in UNET I
 *
 * @file    conv3.c
 * @author  Mandar Chitre
 */

#include <stdio.h>
#include <stdlib.h>
#include "convo2.h"
#include <time.h>

#define STATES       256
#define LARGE        1e9

static unsigned char outputs[STATES] = {
#include "conv3out.dat"
};

static unsigned char *outputs_ptr = &outputs[0];

static inline int nextState(int s, int b)
{
    return (b<<7)|(s>>1);
}

static inline int outBits(int s, int b)
{
    return (b?outputs[s]:(outputs[s]>>4)) & 0x07;
}

static inline float bipolar(int x, int b)
{
    float biplr_opt= ((x>>b)&1)?-1.0:1.0;
	return biplr_opt;
}

/*****************************************************/
/* ORIGINAL branchMetric() function */
/****************************************************
static inline float branchMetric(int s, int b, float* y)
{
    int bm = 0;
    int x = outBits(s,b);
    if (bipolar(x,0)*y[0] < 0) bm++;
    if (bipolar(x,1)*y[1] < 0) bm++;
    if (bipolar(x,2)*y[2] < 0) bm++;
    return (float)bm;
}

**************************************************/

void convo2_init(void)
{
    // do nothing
}

void convo2_enc(float* in, float* out, int len)
{
    int i, s;
    
    s = 0;                                // initial state is 0
    for (i = 0; i < len; i++) {
        int b = (in[i]<0)?1:0;
        int x = outBits(s,b);
        s = nextState(s,b);
        out[i*3] = bipolar(x,0);
        out[i*3+1] = bipolar(x,1);
        out[i*3+2] = bipolar(x,2);
    }
}

void convo2_dec(float* in, float* out, int len, int term)
{
    static unsigned int tb[2*STATES];   // implicit traceback of 32 bits
    static float cost[2*STATES];
    float *curCost, *nextCost;
    unsigned int *curTB, *nextTB;
    int i, j, s, counter;
    int bm0,bm1,s0,s1;
    counter=len/3;
    
    // initialize cost and traceback arrays
    curCost = cost;
    curTB = tb;
    curCost[0] = 0;                     // initial state is 0
    curTB[0] = 0;
    
    
    /****************************************************************/
    /*for (s = 1; s < STATES; s++) {
        curCost[s] = LARGE;
        curTB[s] = 0;
    }*/
    
    
    asm(
	            "yr4=0x1;;" //s
	            "j3=%1;;" //curCost
				"j5=%3;;" //curTB
	            "j4=0x1;yr6=0X0;;" 
	            "yr5=%0;;" //STATES
	            "__loopstart1__:yCOMP(r4,r5);;"
	            "IF yALT,JUMP __loop1__;nop;nop;nop;;"
	            "IF true,JUMP __loopend1__;nop;nop;nop;;"
	            //loops here 
	            "__loop1__:[j3+j4]=%2;;"
				"[j5+j4]=yr6;;"	
	            "j4 = j4 +1;yr4=INC r4;;"
	            "[j3+j4]=%2;;"
				"[j5+j4]=yr6;;"	
	            "j4 = j4 +1;yr4=INC r4;;"
	            "[j3+j4]=%2;;"
				"[j5+j4]=yr6;;"	
	            "j4 = j4 +1;yr4=INC r4;;"
	            "[j3+j4]=%2;;"
				"[j5+j4]=yr6;;"	
	            "j4 = j4 +1;yr4=INC r4;;"
	            "[j3+j4]=%2;;"
				"[j5+j4]=yr6;;"	
	            "j4 = j4 +1;yr4=INC r4;;"
	            "[j3+j4]=%2;;"
				"[j5+j4]=yr6;;"	
	            "j4 = j4 +1;yr4=INC r4;;"
	            "[j3+j4]=%2;;"
				"[j5+j4]=yr6;;"	
	            "j4 = j4 +1;yr4=INC r4;;"
	            "[j3+j4]=%2;;"
				"[j5+j4]=yr6;;"	
	            "j4 = j4 +1;yr4=INC r4;;"
	            "IF true,JUMP __loopstart1__;nop;nop;nop;;"
	            //loops here
	            "__loopend1__:;;"
            :                                                       //outputs
            :"y"(STATES)/*0*/,"y"(curCost)/*1*/,"y"(LARGE)/*2*/,"y"(curTB)/*3*/  	//inputs
            :"yr4","yr5","yr6","j3","j4"    //cloberred registers
	       ); 
    /****************************************************************/
    
    nextCost = cost+STATES;
    nextTB = tb+STATES;
    // Viterbi algorithm
    for (i = 0; i <counter; i++) {
        // output a bit if traceback is about to overflow
        if (i > 31) {
            
            j = 0;
            for (s = 1; s < STATES; s++)
                if (curCost[s] < curCost[j]) j = s;
                            
            out[i-32] = bipolar(curTB[j],31);
        }
        
        /****************************************************************/
        // initialize next state costs
       
         /*for (s = 0; s < STATES; s++)
            nextCost[s] = LARGE;*/
            
            asm(
	            "yr4=0x0;;" //s
	            "j3=%1;;" //nextCost
	            "j4=0x0;;" 
	            "yr5=%0;;"
	            "__loopstart__:yCOMP(r4,r5);;"
	            "IF yALT,JUMP __loop__;nop;nop;nop;;"
	            "IF true,JUMP __loopend__;nop;nop;nop;;"
	            //loops here 
	            "__loop__:[j3+j4]=%2;;"
	            "j4 = j4 +1;yr4=INC r4;;"
	            "[j3+j4]=%2;;"
	            "j4 = j4 +1;yr4=INC r4;;"
	            "[j3+j4]=%2;;"
	            "j4 = j4 +1;yr4=INC r4;;"
	            "[j3+j4]=%2;;"
	            "j4 = j4 +1;yr4=INC r4;;"
	            "IF true,JUMP __loopstart__;nop;nop;nop;;"
	            //loops here
	            "__loopend__:;;"
            :                                                       //outputs
            :"y"(STATES)/*0*/,"y"(nextCost)/*1*/,"y"(LARGE)/*2*/  	//inputs
            :"yr4","yr5","j3","j4"    //cloberred registers
	       );  

	    /*****************************************************************/
        
    // compute next state costs
/******************************************************
//ORIGINAL CODE FOR for LOOP
    for (s = 0; s < STATES; s++) {
        bm0 = curCost[s] + branchMetric(s,0,in+i*3);
        bm1 = curCost[s] + branchMetric(s,1,in+i*3);
        s0 = nextState(s,0);
        s1 = nextState(s,1);
        if (nextCost[s0] > bm0) {
                nextCost[s0] = bm0;
                nextTB[s0] = curTB[s]<<1;
            }
            if (nextCost[s1] > bm1) {
                nextCost[s1] = bm1;
                nextTB[s1] = (curTB[s]<<1)|1;
            }
    }
*******************************************************/            

/******************  OPTIMIZED CODE FOR for LOOP ******************/    
asm(
    //Loop Control
    "yr4=0x0;yr5=0x100;;"
    "__v_comp__:yCOMP(r4,r5);yr15 = 0XBF800000;j9 = yr4;;"
    "IF yALT,JUMP __v_start__;yr21 = 0X0;xr21 = 0X0;;"
    "IF true,JUMP __v_end__;nop;nop;nop;;"
    //Compute bm0,bm1,s0,s1
	"__v_start__:j10 = %2;yr23 = LSHIFT r15 by 0;xr18 = 0XBF800000;;"
	"yr17 =  [j10 + j9];xr22 = LSHIFT r18 by 0;yr22= LSHIFT r15 by 0;xr16 = 0X7;;"
	"xr15 =  [j10 + j9];yr16 = 0X7;yr15 = LSHIFT r17 by 0X3C(nF);xr23 = LSHIFT r18 by 0;;"
	"j9 =  %1;yr20 = r15 AND r16(nF);xr20 = r15 AND r16(nF);yr19 = 0;;"
	"xr16 =  [j9 + 0];yBITEST r20 by 0x00;;"
	"yr16 =  [j9 + 0];xr19 = 0;xBITEST r20 by 0x0;;"
	"IF yseq;do,yr15 = 0X3F800000;;"
	"IF xseq;do,xr18 = 0X3F800000;;"
	"yfr17 = r15 * r16(nF);xfr17 = r18 * r16(nF);;"
	"yBITEST r20 by 0x01;xBITEST r20 by 0x1;yr15 = yr4;;"
	"IF yseq;do,yr22 = 0X3F800000;xr16 =  [j9 + 0x1];;"
	"IF xseq;do,xr22 = 0X3F800000;yr16 =  [j9 + 0X1];;"
	"yFCOMP(r17, r19);xFCOMP(r17, r19);xr4 = yr4;;"
	"IF yalt; do,yr21 = INC r21(nF);yBITEST r20 by 0x02;;"
	"IF xalt; do,xr21 = INC r21(nF);xBITEST r20 by 0x2;;"
	"IF yseq;do,yr23 = 0X3F800000;yfr17 = r22 * r16(nF);;"
	"IF xseq;do,xr23 = 0X3F800000;xfr17 = r22 * r16(nF);;"
	"yFCOMP(r17, r19);xFCOMP(r17, r19);yr16 =  [j9 + 0X2];;"
	"IF xalt; do,xr21 = INC r21(nF);yfr17 = r23 * r16(nF);;"
	"IF yalt; do,yr21 = INC r21(nF);xr16 =  [j9 + 0x2];;"
	"yFCOMP(r17, r19);xfr17 = r23 * r16(nF);j10 = %3;;"
	"IF yalt; do,yr21 = INC r21(nF);xFCOMP(r17, r19);;"
	"IF xalt; do,xr21 = INC r21(nF);yfr18 = FLOAT r21(nF);;"
	"j9=yr4;xfr18 = FLOAT r21(nF);yr16 = 0X00;;"
	"yr23=[j10+j9];xr5 = 0X01;xr6 = ASHIFT r4 by 0X3F(nF);;"
	"yfr21 = r18+r23;xr23=[j10+j9];j10=%4;;"
	"xfr21 = r18+r23;yr17 = ASHIFT r15 by 0X3F(nF);j12=%5;;"
	"yr18 = LSHIFT r16 by 0X7(nF);xr7 = LSHIFT r5 by 0X7(nF);j11=%6;;"
	"yr15=r17 OR r18;xr4 = r7 OR r6;j8=yr4;;"//s0;s1
	//If conditions
	"j9=yr15;;"
	"yr16 = [j10+j9];;"
	"j13=xr4;;"
	"xr5 = [j10 + j13];;"
	"yCOMP(r21,r16);xCOMP(r21,r5);;"
	//first if condition
	"IF yalt,JUMP __great1__;nop;nop;nop;;"
	"IF xalt,JUMP __great2__;nop;nop;nop;;"
	"IF true, JUMP __less2__;nop;nop;nop;;"
	"__great1__:[j10+j9]= yr21;;"
	"yr18=[j11 + j8];;"//curTB[s]
	"yr19=LSHIFT r18 by 0x1;;"
	"[j12 + j9]=yr19;;"//nextTB[s0]
	//second if condition
	"IF xalt,JUMP __great2__;nop;nop;nop;;"
	"IF true,JUMP __less2__;nop;nop;nop;;"
	"__great2__:[j10+j13]= xr21;;"
	"xr18=[j11 + j8];;"//curTB[s]
	"xr19=LSHIFT r18 by 0x1;xr20=0x1;;"
	"xr6=r19 OR r20;;"
	"[j12 + j13]=xr6;;"
	"__less2__: yr4 = INC r4;;"
    "IF true,JUMP __v_comp__;nop;nop;nop;;"
    "__v_end__:;;"
	
:		//outputs
:"y"(STATES)/*0*/,"y"(in+i*3)/*1*/,"y"(outputs_ptr)/*2*/,"y"(curCost)/*3*/,"y"(nextCost)/*4*/,"x"(nextTB)/*5*/,"x"(curTB)/*6*/  	//inputs
:"yr4","yr5","yr15","yr16","yr17","yr19","yr20","yr21","yr22","yr23",
 "xr4","xr5","xr6","xr7","yr18","xr15","xr16","xr17","xr18","xr19","xr20","xr21",
 "xr22","xr23","j8","j9","j10","j11","j12","j13");  //cloberred registers

/*****************************************************/    
       
        
        // swap state cost and traceback buffers
        curCost = nextCost;
        curTB = nextTB;
        if (curCost == cost) {
            nextCost = cost+STATES;
            nextTB = tb+STATES;
        } else {
            nextCost = cost;
            nextTB = tb;
        }
    }
    // output remaining bits
    j = 0;
    if (!term) {
        for (s = 1; s < STATES; s++)
            if (curCost[s] < curCost[j]) j = s;
    }
    
    #pragma vector_for
    for (i = 31; i >= 0; i--)
        out[len/3-i-1] = bipolar(curTB[j],i);

        
}
